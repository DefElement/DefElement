"""Perform verification checks."""

import argparse
import json
import os
import typing
from datetime import datetime

from defelement import settings
from defelement.element import Categoriser, Element
from defelement.implementations import parse_example, verifications, versions
from defelement.verification import verify

start_all = datetime.now()

parser = argparse.ArgumentParser(description="Verify elements")
parser.add_argument(
    "destination",
    metavar="destination",
    nargs="?",
    default=None,
    help="Name of output json file.",
)
parser.add_argument("--test", metavar="test", default=None, help="Verify fewer elements.")
parser.add_argument(
    "--processes",
    metavar="processes",
    default=None,
    help="The number of processes to run the verification on.",
)
parser.add_argument(
    "--fail-on-missing-libraries",
    action="store_true",
    help="Fail if library is not installed.",
)
parser.add_argument(
    "--print-reasons", action="store_true", help="Show reasons for failed verification"
)
parser.add_argument(
    "--assert-passing",
    action="store_true",
    help="Assert that verification passes for all elements",
)
parser.add_argument(
    "--impl", metavar="impl", default=None, help="libraries to run verification for"
)

args = parser.parse_args()
if args.destination is not None:
    settings.set_verification_json(args.destination)
if args.processes is not None:
    settings.set_processes(int(args.processes))
if args.test is None:
    test_elements = None
elif args.test == "auto":
    test_elements = [
        "buffa-christiansen",
        "direct-serendipity",
        "dual",
        "hellan-herrmann-johnson",
        "hsieh-clough-tocher",
        "lagrange",
        "nedelec1",
        "raviart-thomas",
        "regge",
        "serendipity",
        "taylor-hood",
        "vector-bubble-enriched-Lagrange",
        "enriched-galerkin",
        "bernardi-raugel",
    ]
else:
    test_elements = args.test.split(",")
if args.impl is None:
    test_implementations = None
else:
    test_implementations = args.impl.split(",")
skip_missing = not args.fail_on_missing_libraries
print_reasons = args.print_reasons
assert_passing = args.assert_passing

categoriser = Categoriser()
categoriser.load_references(os.path.join(settings.data_path, "references"))
categoriser.load_families(os.path.join(settings.data_path, "families"))

# Load elements from .def files
categoriser.load_folder(settings.element_path)

elements_to_verify = []
for e in categoriser.elements:
    if test_elements is None or e.filename in test_elements:
        for eg in e.examples:
            implementations = [
                i
                for i in verifications
                if i != "symfem"
                and e.implemented(i)
                and (test_implementations is None or i in test_implementations)
            ]
            if len(implementations) > 0:
                elements_to_verify.append((e, eg, implementations))


def verify_example(
    element: tuple[Element, str, list[str]],
) -> dict[str, dict[str, dict[str, list[str]]]]:
    """Verify example.

    Args:
        element: The element, example and list of implementations

    Returns:
        Results of verification
    """
    e, eg, implementations = element

    green = "\033[32m"
    red = "\033[31m"
    blue = "\033[34m"
    default = "\033[0m"

    results: dict[str, dict[str, dict[str, list[str]]]] = {}

    if e.filename not in results:
        results[e.filename] = {}
    cell = eg.split(",")[0]

    reference, defelement_degree, variant, kwargs = parse_example(eg)
    assert len(kwargs) == 0
    symfem_name, symfem_degree, symfem_params = e.get_implementation_string(
        "symfem",
        reference,
        defelement_degree,
        variant,
    )
    assert symfem_degree is not None
    sym_info = verifications["symfem"](symfem_name, reference, symfem_degree, symfem_params, e, eg)
    for i in implementations:
        # Implementations generated from other implementations (eg Basix code generated by Symfem)
        if i.startswith("*(") and i.endswith(")"):
            input_code, output_code = i[2:-1].split(" -> ")
            if e.implemented(output_code) or not e.implemented(input_code):
                continue
        # Standard implementations
        else:
            input_code = i
            output_code = i

        if output_code not in results[e.filename]:
            results[e.filename][output_code] = {
                "pass": [],
                "fail": [],
                "not implemented": [],
            }

        # Do the verification
        try:
            impl_name, impl_degree, impl_params = e.get_implementation_string(
                input_code,
                reference,
                defelement_degree,
                variant,
            )
            assert impl_degree is not None
            vinfo = verifications[i](impl_name, reference, impl_degree, impl_params, e, eg)
            v, info = verify(cell, vinfo, sym_info)
            if v:
                results[e.filename][output_code]["pass"].append(eg)
                print(f"{e.filename} {i} {eg} {green}\u2713{default}")
            else:
                results[e.filename][output_code]["fail"].append(eg)
                print(f"{e.filename} {i} {eg} {red}\u2715{default}")
                if print_reasons:
                    print(f"  {info}")
        except KeyboardInterrupt:
            raise KeyboardInterrupt
        except ImportError as err:
            if skip_missing:
                print(f"{output_code} not installed")
            else:
                raise err
        except NotImplementedError:
            results[e.filename][output_code]["not implemented"].append(eg)
            print(f"{e.filename} {i} {eg} {blue}\u2013{default}")
        except BaseException as err:
            results[e.filename][output_code]["fail"].append(eg)
            print(f"{e.filename} {i} {eg} {red}\u2715{default}")
            if print_reasons:
                print(f"  {type(err).__name__}: {err}")

    return results


if settings.processes == 1:
    results = [verify_example(e) for e in elements_to_verify]
else:
    from multiprocessing import Pool

    with Pool(settings.processes) as p:
        results = p.map(verify_example, elements_to_verify)

data: dict[str, dict[str, dict[str, list[str]]]] = {}
for r in results:
    for i0, j0 in r.items():
        if i0 not in data:
            data[i0] = {}
        for i1, j1 in j0.items():
            if i1 not in data[i0]:
                data[i0][i1] = {}
            for i2, j2 in j1.items():
                if i2 not in data[i0][i1]:
                    data[i0][i1][i2] = []
                data[i0][i1][i2] += j2

now = datetime.now().strftime("%Y-%m-%d")
metadata: dict[str, typing.Any] = {"date": now}

try:
    with open(settings.verification_history_json) as f:
        history = json.load(f)
except FileNotFoundError:
    history = {}

for impl in set(j for i in data.values() for j in i):
    metadata[impl] = {"version": versions[impl]()}
    if impl not in history:
        history[impl] = []
    history[impl].append(
        {
            "date": now,
            "pass": sum(len(i[impl]["pass"]) for i in data.values() if impl in i),
            "version": versions[impl](),
            "total": sum(
                len(i[impl]["pass"]) + len(i[impl]["fail"]) for i in data.values() if impl in i
            ),
        }
    )


with open(settings.verification_json, "w") as f:
    json.dump(
        {
            "metadata": metadata,
            "verification": data,
        },
        f,
    )
with open(settings.verification_history_json, "w") as f:
    json.dump(history, f)

if assert_passing:
    for d in data.values():
        assert len(d[impl]["fail"]) == 0
